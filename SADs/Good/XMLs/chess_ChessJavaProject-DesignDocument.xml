<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>2f517df7e9c31820917b8bedaa0c7f45a02c16bf242e9df9f162259f2c949818</job>
    <base_name>18wf</base_name>
    <doi>http://dx.doi.org/10.3840/003377</doi>
    <warning>Name identification was not possible. </warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1">Chess Java Project - Design Document</article-title>
      </title-group>
      <outsider class="DoCO:TextBox" type="outsider" id="3"> Shortlink: <ext-link ext-link-type="uri" href="http://goo.gl/5vBez9." id="2">http://goo.gl/5vBez9.</ext-link> </outsider>
      <region class="DoCO:TextChunk" id="4" confidence="possible">Overview The Chess Project implements a webservice for managing chess games, and two clients, a  commandline client and an Android application client.  The project contains a toplevel Maven project called “Chess”, and 6 subprojects:  ● Board  chess logic library  ● Protocol  chess service protocol library  ● Server  chess service server  ● Client  chess service client library  ● AndroidApp  the android application.  ● Shell  the shell client  High Level Design</region>
      <region class="DoCO:FigureBox" id="Fx5">
        <image class="DoCO:Figure" src="18wf.page_001.image_01.png" thmb="18wf.page_001.image_01-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="footer" id="6">The client applications also use classes  from the  board  library, such as Coordinate and Piece.  The  Protocol  library is a thin library that defines the communication protocol and provide basic  tools for managing the requests. It is used by the  client library  and the  server , and is in its own  project only to prevent a dependency between the  client  project and the  serer  project.  Protocol Requests and Responses Structure The requests and responses are defined using Google ProtocolBuffers.  The messages are defined in chess.proto in the  Protocol  project. </outsider>
      <outsider class="DoCO:TextBox" type="header" id="7">Network Protocol While internally both the client and server use ProtocolBuffers, the endpoint modules on both  sides translate outgoing messages to JSON and incoming messages back from JSON to  ProtocolBuffer messages. </outsider>
      <region class="unknown" id="8">The translation is done using protobufjavaformat, which determines the exact JSON format. </region>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="deo:Methods">
        <h1 class="DoCO:SectionTitle" id="9" confidence="possible" page="2" column="1">Methods</h1>
        <region class="DoCO:TextChunk" id="10" page="2" column="1">The server exposes the following methods:  login(LoginRequest) → LoginResponse The  login  method is used for logging in and starting a new session. The session token, returned  as part of the LoginResponse, is the identifier of the session, and must be used in any future  requests in the same session.  seek(SeekRequest) → SeekResponse The  seek  method is used for seeking an opponent. This method may halt for a long time, and  even timeout, in case there are no opponents looking for a game.  The game identifier, returned as part of the SeekResponse, is the identifier of the game, and  must be used in any future requests in the context of the game.  Once the game started, it is possible to start listening to game event (see  getEvents ).  getEvents(EventsRequest) → EventsResponse The  getEvents  method is used for polling the server for game events. Game events are any  moves made, draw offers, resignation, etc. The  client  library starts listening for event  automatically at the beginning of a game.  This method may not return immediately, but only when a new event happens in the game. It  may also timeout in case no events happen for a long time. This is fine in the case of  getEvent ,  and the  client  library will continue polling for events in case of timeout.  All events are sent to all players, including events initiated by the player. This allows clients to  know that the event was handled and added to the game events list, thus the other player will  also get the event. </region>
        <outsider class="DoCO:TextBox" type="footer" id="11" page="2" column="1">Game actions ● move(MoveRequest) → ErrorResponse  Used for making a move.  ● resign(GameInfo) → ErrorResponse  Used for resigning the game.  ● offerDraw(GameInfo) → ErrorResponse  Used for offering or accepting a draw. Offering  and accepting draw are considered logically equal, as the condition for draw by  agreement is that both players agree on draw at the same time, regardless of who was  the side that offered and who was the side that accepted.  ● declineDrawOffer(GameInfo) → ErrorResponse  Used for declining a draw offer.  ● getPosition(GameInfo) → PositionResponse  Used for getting the current board position  of the game. </outsider>
        <outsider class="DoCO:TextBox" type="header" id="12" page="3" column="1">Detailed Design Board Library</outsider>
        <region class="DoCO:TextChunk" id="13" confidence="possible" page="3" column="1">The board library implements the chess logic. It includes the following classes.  Main classes:  ● Game  Represents a chess game.  ● Piece  Represents a chess piece. This is a base class with subclasses for each piece  type.  ● Coordinate  Represents a coordinate on the chessboard.  ● Position  Represents a chess position.  The library is fully documented here. </region>
        <region class="DoCO:TextChunk" id="14" page="3" column="1">Protocol Library The protocol library contains the protocol definition (chess.proto), and the class JsonParser that  is used for translating JSON to protobuf and protobuf to JSON.  The JsonParser class is used at endpoints in order to hide the network protocol from the  implementation.  The library is fully documented here. </region>
        <region class="DoCO:TextChunk" id="15" confidence="possible" page="3" column="1">Server Library The server library contains several classes. The most important among them are: </region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="16" confidence="possible" page="3" column="1">ServiceImpl</h1>
        <region class="unknown" id="17" page="3" column="1">The ServiceImpl class implements the logic for all exposed methods.  Because of the way the methods are exposed (see RequestHandler), all public methods must  have a Status return value and take exactly 2 params, where the first is a proto message and the  second is a ServiceImpl.Callback.  When adding a method that comply with that standard, this method will automatically be  exposed by the RequestHandler.  This hides the request handling form the ServiceImpl library, completely decoupling it from the </region>
        <outsider class="DoCO:TextBox" type="footer" id="19" page="3" column="1">network protocol.  RequestHandler The RequestHandler class is the request handler module that handles all request.  The RequestHandler creates a map of ServiceImpl’s public methods.  All requests are handled using<email id="18"> ‘@GET </email>@Path(value="/{method}")’. When receiving a request,  the RequestHandler looks for the method name in the map, and if it exists, invokes it with a  protocolbuffer message translated from the request’s JSON.  The request handler is the only class in the server aware of the JSON network protocol. By  designing the server library this way, we allow replacing the network protocol by replacing the  request handler, without changing ServiceImpl, or any other class.    The library is fully documented here. </outsider>
        <outsider class="DoCO:TextBox" type="header" id="20" page="4" column="1">Client Library The client library contains several classes. The most important among them are:  HttpGetter</outsider>
        <region class="DoCO:TextChunk" id="21" page="4" column="1">The HttpGetter class is the only class aware of the JSON network protocol on the client side. It  exposes a thin interface with just a single method that allows calling a method by name, passing  the request as protocolbuffer message and receiving the response as one.  By designing the client library this way, we allow replacing the network protocol by replacing the  http getter with another class providing a similar method (at which case, an interface should be  extracted). </region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="22" confidence="possible" page="4" column="1">Client</h1>
        <region class="DoCO:TextChunk" id="23" confidence="possible" page="4" column="1">The client class exposes all the methods that the client application needs in order to  communicate with the server. It manages the session and the game in a way that does not  require other modules to be aware of the session token or the game id.    The startListeningToEvents method tells the client to start listening to events. This invokes a new  thread dedicated to listening to game events and handling them as they happen.    The library is fully documented here.  AndroidApp The Android application contains two activities and a service: </region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="24" confidence="possible" page="4" column="1">LoginActivity</h1>
        <region class="DoCO:TextChunk" id="25" confidence="possible" page="4" column="1">The login activity is a relatively simple activity, responsible for logging in to the server. Once  logged in, the board activity is activated. </region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="26" confidence="possible" page="4" column="1">BoardActivity</h1>
        <region class="DoCO:TextChunk" id="27" confidence="possible" page="4" column="1">The board activity is the main activity of the application, allowing the use to seek an opponent  and play a game. </region>
        <outsider class="DoCO:TextBox" type="footer" id="28" page="4" column="1">ChessClientService The chess client service is an Android service for the chess client. It uses the client library for  communication with the chess server.    The library is fully documented here.  Shell The ShellClient is a small library, containing just a single class called “ShellClient”.  This class contains a main function that instantiates it and runs it. Once running, it provides full  client functionality, using the client library, in an interactive shell.    The library is fully documented here. </outsider>
        <outsider class="DoCO:TextBox" type="header" id="31" page="5" column="1">Links ● Design document (this document): <ext-link ext-link-type="uri" href="http://goo.gl/5vBez9" id="29">http://goo.gl/5vBez9</ext-link>  ● Javadoc documentation: <ext-link ext-link-type="uri" href="http://gilran.github.io/chess/javadoc/" id="30">http://gilran.github.io/chess/javadoc/</ext-link> </outsider>
        <region class="unknown" id="32" page="5" column="1">● GitHub project: https://github.com/gilran/chess  ● HTTPS git clone url: https://github.com/gilran/chess.git  ● Project sources ZIP: https://github.com/gilran/chess/archive/master.zip  ● Project README: https://github.com/gilran/chess/blob/master/README </region>
      </section>
    </body>
  </article>
</pdfx>
