Sentence

Category

2 Requirement Analysis

Requirements

In order to start gathering requirements, first it is necessary to identify each group affected by  this project and understand everyone’s needs (section Stakeholders Analysis 2.1).

Requirements

With that  information in hand, an initial list of the desired functional and non-functional requirements (see sections Functional Requirements 2.2 and Non-Functional Requirements 2.3) can be put  into the Product Backlog in the form of user stories

Requirements

Every sprint these requirements may  change, reason why in this section are described only the final requirements that are part of  the current Product Backlog of the project (see Appendix B Product Backlog).

Requirements

2.1 Stakeholder Analysis

Requirements

Potential clients of the project, simplified as “clients” from now on, are companies in need of  an e-commerce solution, especially those looking for an interface from where to sell goods or  services to individuals or other companies.

Requirements

They need a system that satisfies their current  requirements and allows them to easily implement future required functionalities.

Requirements

They hire  developers, usually working in agencies, to build these tailored applications.

Requirements

Potential users of the template are precisely developers, who need to implement a web-shop or  a similar application. 

Requirements

They might have to decide whether to develop a web-shop based on  SPHERE.IO Play SDK. 

Requirements

They may want to use the template as a live documentation of how to  use the system or directly use it as a bootstrap project on which to build their own web-shop. 

Requirements

They need to easily understand the sample code and quickly identify those lines of code with  shop logic coming from SPHERE.IO. 

Requirements

Code quality and correct use of technologies may be  important for them.

Requirements

End users or customers 7 , equally mentioned as “users” and “customers” in this document, are  those actors of the system who would buy in the web-shop in case it went live.

Requirements

Even being an  hypothetical situation, this template will be used as a bootstrap project so eventually it will  become a real web-shop with end users.

Requirements

"With no other specific information about these users,  it can only be assumed that they need an intuitive layout that allows them to shop with ease in  a few clicks.                                                             "

UI design

Inside the company there are two major stakeholders: the SPHERE.IO product owners and the  developer team. 

Requirements

The product owners need a final product where all the platform features are  implemented in order to measure the actual progress of the project.

Requirements

This product also allows  them to have a sample web-shop to show to potential clients in meetings and conferences even  before the platform is released.

Requirements

On the other hand, the development team is in charge of designing and implementing the  platform that the template is using.

Requirements

Their primary need towards the template is to verify that  their implementation is adjusting to both developers and clients needs. 

Requirements

They might create  temporal limitations on the template design, but at the same time any suggestion may be  quickly adopted with no need to change the web-shop requirements.

Uncertain

2.2 FUNCTIONAL REQUIREMENTS

Requirements

In order to prove the value of the platform and identify any possible lack of functionality, the  application should have all the common features of a regular web-shop.

Requirements

Accordingly, it has been considered that the initial appropriate set of functionalities for this project include those related to browsing and purchasing products, as well as management of a customer account.

Requirements

The detailed behavior expected for the web-shop is described below.

Document Organisation

In the home page all products are displayed sorted by popularity. 

UI design

From here the user can select a category; then all products belonging to that category or any descendent will be displayed.

Use Case

Whenever a set of products is listed, those products on sale will be highlighted and  the user will be given the option to sort and filter amongst all products.

Use Case

The sorting can be  performed by name or price, and the filtering by price and color. 

Requirements

Each product thumbnail  consists of a picture of the product, its name and price, as well as a list of all color variants  available.

UI design

Clicking on a product thumbnail redirects the user to the product detail page, where besides  name and price also a description is shown. 

Use Case

Here the user is able to select any color and size to  visualize the corresponding picture.

Use Case

In any moment the user can add the selected product to  the shopping cart, afterwards the updated cart contents and total price will be displayed.

Use Case

Accessing the cart details also grants the user the possibility to change the number of units of  an item or remove any particular item from the shopping cart.

Use Case

From here the user can choose to start the checkout process, where he is asked to fill a form  with shipping information (i.e. shipping address and method) and billing information (i.e. billing address and payment data).

Use Case

During the checkout process the order summary (i.e. the  list of purchased items and pricing details) is displayed all along and kept up to date. 

UI design

Right  before finishing the checkout process, the user is informed of all introduced shipping and  billing information as well as the order summary. 

Use Case

Once the checkout process is finished,  another summary is shown along with a successful purchase message.

Use Case

The user can decide to sign up in our systems, in which case he must provide his full name,  email address and a password. 

Use Case

After signing up he is redirected to his user profile, where he  can update his personal data, change his password, manage his address book or review his  previous orders in detail.

Use Case

The address book allows the user to store a set of postal addresses  that can later be selected as shipping or billing address in the checkout process. 

Use Case

The user is  allowed to add new addresses to the address book, as well as update or remove any stored  address.

Use Case

While logged in, the user can choose to log out in order to become an anonymous customer. 

Use Case

In  any moment, he can log in again providing his email address and password.

Use Case

In case the user  forgot his password, he can request to recover it by entering his email address, in which case  an email is then sent to the address provided containing a web link can then be accessed  within the next hour, where the user can provide a new password.

Use Case

2.3 Non-functional requirements

Requirements

In its first stage, the web-shop template is required mainly to analyze the platform capabilities,  show code examples to developers and attract potential customers.

Requirements

For this reason all nonfunctional requirements are highly focused on those areas. 

Requirements

Other areas of great importance as  well, such as compatibility and performance, are left aside from the current project because of  the excessive workload that it means.

Requirements

From a developer point of view the quality of the code takes a very important role, so it should  be well organized, easy to understand and reusable. 

Development

Therefore it would be considered a good  practice to use variables and functions with self-explanatory names and keep a well  commented code.

Development

To the extent possible, the generic shop logic should be separated from the most specific code in order to facilitate the use of it as a live documentation of the platform.

Development

The platform should allow to test any web application built on top of it.

Testing

In order to prove it is  allowed, the template should be completed with automated functional tests, being careful of  keeping these tests independent from the backend data in use. 

Testing

That way a change in the data,  very likely to happen in a template web-shop, will not affect the results.

Uncertain

The same principle  should be applied to the code in general, to keep the template from being non-functional when  the data used is different.

Uncertain

Although major part of the required security is located on the e-commerce and payment  platforms, there are some risks server side that must be top priority when it comes to online  shopping.

uncertain

For example some data needs a careful treatment, like user related data such as  addresses, passwords and payment information. 

Requirements

Particular attention must be paid with the  checkout process in order to avoid fraud.

Requirements

When online payment is involved in an application, payment data needs to be processed and  stored somewhere. 

data

The system to process and store this data needs to be PCI DSS8 compliant.

Requirements

Being a sample web-shop it is most appropriate in this case to leave this role to the payment  platform, thus sending any payment data to the template’s web server must be strictly avoided.

Development

The template should be intuitive and use latest design tendencies, especially those allowing a  faster navigation experience.

Requirements

The user should be able to use all functionalities of the web-shop  in a smooth way, trying to minimize the number of times the page is fully reloaded. 

Requirements

This will  also speed up the communication with the web server, thereby favoring a more efficient  interaction with the web-shop.

Requirements

The colour scheme should be neutral but pleasant in order to match any web-shop topic, with  a winter sports related theme. 

Requirements

The URL structure of each page needs to be user-friendly,  meaning it has to be easily identifiable with the product or category linked when reading it. 

Requirements

At  the same time it has to follow some basic SEO rules in order to promote any website based on  this template.

Requirements

3 Specification

Uncertain

Agile methodologies suggest to elaborate documentation only as needed, without having any required artifacts for each stage as traditional methodologies usually do. 

Uncertain

The reason why heavy  documentation is not recommended is because requirements are expected to change  constantly during the development process, forcing to update every diagram and text each  time a change is applied, with the consequent loss of time that could have been otherwise used  to develop the product.

Uncertain

For this reason, only some simplified diagrams were drawn during the specification and design  stages, the necessary to understand the system and share ideas with the SPHERE.IO team. 

Uncertain

Therefore most of the artifacts presented in both this section and section Design 4, were made  after the product was already built, intended to assist the reader in understanding better the  system.

Document Organisation

The specification section here presented describes the necessary system to fulfill the functional  requirements previously gathered

Document Organisation

Here are first described the set of use cases that are initially  planned for the project, which corresponds to the final Product Backlog (see list in Appendix B Product Backlog).

Document Organisation

The conceptual model of this system is then presented and, for each use case, is explained the expected behavior of the system with the user.

Document Organisation

3.1 Use Case Model

Use Case

There are three actors that interact with the system: the customer, the payment platform and the SPHERE.IO e-commerce platform (Figure 3.1). 

Development

The customer can either be an anonymous  customer or an identified customer previously existing in the SPHERE.IO platform. 

uncertain

Since the  required functionalities of the present project were mainly designed to test the SPHERE.IO platform, it is no surprise that the platform is present in every single use case of the system  whatsoever, so for the sake of readability it will be omitted from the use case diagrams  henceforth.

uncertain

As mentioned earlier, the system has three functionalities where all use cases fall into: display  products, purchase products and manage customer account (Figure 3.2).

Requirements

The customer is  present in all use cases of the system, while the payment platform is only involved in the  functionality for purchasing products.

uncertain

The use cases for displaying products are shown below in Figure 3.3.

uncertain

The customer can either list a set of products or display a particular product.

Requirements

Further additional functionalities can be  applied to the product listing, individually or combined together, in order to alter the list itself (i.e. filtering) or the way the products are listed (i.e. sorting and pagination).

uncertain

Figure 3.4 shows the use cases related to purchasing products. 

uncertain

They can be clearly divided into  two different topics: on the one hand all those use cases for managing the shopping cart (i.e. adding, updating and removing items), on the other hand those related to placing and listing  orders.

uncertain

When placing an order the customer may be requested to pay online, in which case the payment platform will provide the necessary means. 

Use Case

Anonymous as much as registered  customers can place orders, but only customers that have been identified are able to list their  own orders, otherwise they are requested to identify themselves.

Use Case

Finally, for the use cases related to account management (Figure 3.5), a registered customer  can manage his address book (i.e. add, update or remove postal addresses) or update his  account (i.e. change his personal data or password). 

Use Case

He can as well decide to log out from the  system and become an anonymous customer. 

Use Case

As an anonymous customer, he can sign up a  new account or log in with an existing one. 

Requirements

In case he cannot remember his credentials, he will  be given the option to recover his password.

Use Case

The previously explained use cases are mostly useful to define the scope of the project and  understand its functionalities.

uncertain

For example, these use cases can be helpful to estimate tasks  and elaborate the development plan, as well as a guide to determine the necessary functional  tests for the system. 

uncertain

But these use cases are too granular for other purposes, such as defining  acceptance tests or describing the sequence of user interactions with the system. 

uncertain

These tasks  require a more abstract level of use cases, focused on user goals instead of functionalities,  sometimes called top-level use cases.

uncertain

A top-level use case describes a single elementary business process that allows a particular  user to fulfill a goal. 

uncertain

In this system there are mainly three goals that a customer may want to  achieve when he uses the web-shop, as shown in Figure 3.6

Requirements

The first one consist of browsing  the catalog and selecting those products of interest.

Requirements

At some moment, the user can decide to  review the selected items and eventually buy them, which is the second goal.

Use Case

Finally, the third  goal involves checking the payment or shipping status of the order, or any additional related  information. 

Requirements

All low-level use cases defined earlier are actually providing the functionalities to fulfill these  three goals. 

uncertain

Both low-level and top-level use cases are being used indistinctly throughout this  document to elaborate other diagrams and descriptions, its use responding mostly to the level  of abstraction that fits best the explanation. 

uncertain

In any case, the term “top-level” is expressly used  when referring to this type of use case.

uncertain

3.2 System behavior model

uncertain

Almost all the low-level use cases of this project consist of only one interaction between the  user and the system.

uncertain

This may be useful for projects that require very detailed information  about the system to be developed, possibly because its behavior is very specific and unique.

uncertain

But this is not the case of this project whatsoever, the use cases defined here are precisely very  common amongst web-shops, so any operation offered by this system is considered to be selfexplanatory.

uncertain

As mentioned before, the top-level use cases are here more appropriate to describe the user  communication with the system.

Use Case

This is because they provide information not only about the  system behavior, but also about the sequence of interactions that the customer usually  performs in order to achieve a goal.

uncertain

Figure 3.7 displays the sequence diagram for the browse catalog top-level use case, one of the  many possible success scenarios.

Use Case

In this case the user will usually go to the home page, select a 40 category and then filter or sort the products until he eventually finds one of interest.

Use Case

Then he  will probably ask for the details of the product and next he will add it to the shopping cart.

Use Case

The checkout top-level use case is shown in Figure 3.8. 

Use Case

Once the customer has some line items  in his shopping cart, the next step is to navigate to the cart page

Use Case

Here the user can remove or  modify his line items until he is ready to start the checkout process. 

Use Case

There, after entering all  shipping and billing information, the customer will confirm the purchase and the system will  request the payment platform to process the payment, displaying the order details in response  to the customer.

Use Case

The last sequence diagram displays the interactions that the customer has to perform in order  to check the state of an order (Figure 3.9).

Use Case

This scenario requires the customer to previously  sign up to the system and purchase some items as a registered customer. 

Use Case

Then at any moment  the user can go to the login page and enter the login information to access his customer profile.

Use Case

There he can select to list all his orders and select the one he wants to view in detail.

Use Case

3.3 Conceptual Model

Uncertain

The conceptual model of this project revolves around the cart concept, while all other system elements are there to provide the required information to the cart, as seen in the class diagram  below (Figure 3.10).

uncertain

Products are related to carts as a list of product variants, forming line items.

uncertain

Variant is a concept to define the part of the product that contains the particular  characteristics of it, such as color or size, even having sometimes a different price.

uncertain

Therefore  every product has at least one variant, each one with different price or attributes.

Requirements

Similarly, a cart can be associated with one of the shipping methods available in the system,  resulting in a shipping item, necessary to manage taxes

Requirements

Both products and shipping methods  have a particular tax category, that can be variable for products and fixed in the case of  shipping.

Requirements

When one of these elements are added to the cart, a tax rate is assigned to the item  according to this tax category and the shipping address of the cart.

Requirements

As mentioned above carts can have a shipping address, but can have as well a billing address.

Requirements

A cart can belong to a registered customer, otherwise it is considered to have an anonymous  customer. 

Requirements

Once the checkout is finished a cart becomes an order, with information about the  current payment, shipping and order status. 

Requirements

If the customer was not anonymous, this order will be associated with that customer, along with any of his previous orders.

Requirements

Every customer  can also have a list of addresses comprising the address book.

Requirements

Products, addresses and shipping methods can change or disappear over time, but the orders  associated with them must stay in the system for an indefinite period of time, having exactly the original information

uncertain

To solve this issue, cart is not related to the original instances, but to  instances that were created exclusively for this particular cart as a snapshot of those original  instances. 

Uncertain

While the current cart may optionally have associated information, this information  is mandatory in an order instance.

Requirements

For simplicity, the conceptual model only accepts product and shipping prices that do not  include taxes. 

uncertain

Allowing taxes in prices can be achieved by simply adding a boolean attribute  indicating whether the price in question has taxes included or not.

uncertain

So assuming that taxes are  not included, the net total price in the cart must be the sum of all the line item prices (i.e. the  quantity in each line item multiplied by the corresponding variant price) associated with it,  plus the price of the shipping method selected.

Requirements

In order to calculate the gross total price, taxes  must be added up to this resulting net price.

Requirements

Taxes are calculated multiplying the price of each  shipping or line item by its corresponding tax rate.

Requirements

Lastly when the shipping address is set in the cart, all tax rates from shipping and line items  are calculated. 

Requirements

Only those products that include a tax category corresponding to the zone (e.g. state, country) of the shipping address can be part of the cart.

Requirements

Missing the tax category means  that the price cannot be calculated, thus the product is not available in that zone.

Requirements

3.4 State Diagrams

Uncertain

There are two interesting state diagrams of this system, both related to the cart element. 

uncertain

The first diagram (Figure 3.11) describes how a cart instance changes until it becomes a complete order.

uncertain

As the diagram below shows, the current cart is the initial state, which allows to change  its contents in multiple ways, such as adding or removing line items or selecting a shipping  address.

uncertain

Once the checkout is finished the cart becomes an order, being this an irreversible  change. 

Requirements

From now on the order can only change from an open to a complete state, and vice versa.

Requirements

The second diagram (Figure 3.12) describes the whole process of managing the shopping cart  and eventually purchasing these products in the checkout process.

uncertain

This diagram will become  especially useful when designing the checkout interface, as it clearly displays the requirements  of each step of the checkout process

uncertain

At the beginning of the process a new cart is created

Requirements

Once the cart contains an item it can be  further updated, then at any moment the user can start or exit the checkout process. 

Use Case

Initially the checkout process requires a shipping address to display the shipping methods, then it requires a shipping method to display billing options.

Requirements

Of course this sequence can be skipped  if the cart has already these requirements.

Requirements

When the user provides the billing information and finalizes the checkout, the system charges  the customer

Use Case

The order is then created after the payment platform confirms that the payment  was successful. 

Requirements

The moment the previous cart becomes an order, a new cart is created for the  customer in order to start the process once again.

Requirements

4 Design

Uncertain

The software design describes the final details of a system before it is implemented

uncertain

During the design process decisions are taken in order to meet the gathered requirements, decisions that are then applied to the system defined in the section Specification 3. 

uncertain

Both physical and logical designs of the system are described in detail in the current chapter (sections System Physical Architecture 4.1 and System Logical Architecture 4.2), with an overview of how the resulting product needs to be implemented. 

Document Organisation

Every technology used is carefully justified and the major characteristics are explained (section Description of Used Technologies 4.2.1). 

Document Organisation

The selection of a technology is a decisive process aimed to obtain the optimal results of a project

uncertain

An unwise decision can sometimes seriously affect the total resources needed or the successful fulfillment of the proposed objectives.

uncertain

It is also important to design correctly the structure of the system, for example identifying and applying the software patterns that can solve existing problems in this particular project. 

Development

4.1 System Physical Architecure

uncertain

The designed system follows a client-server architecture with three tiers: the client, the web application server and the data server tier.

Development

The data tier corresponds to the SPHERE.IO  backend, which offers a scalable cloud-based platform for the e-commerce data, having the  capability of scaling up as the demand increases

Development

The application tier needs an enterprise  hosting solution, suitable for a company web-shop.

Development

In order to take advantage of the scalability of the data tier, a good matching web hosting solution would be a cloud service with easy and fast scalability, letting the shop grow as the number of customers grow, without any bottleneck

uncertain

At the time the system was designed there were only two cloud platforms with built in support for deploying Play applications: Heroku and Cloudbees; although at the end of 2013 the number of services has been doubled and the offer will probably continue to increase in the future.

Development

Both services enable a simple automated deployment of the web application to the platform, which will allow developers to have a working hosted application within minutes. 

Development

The specific hosting solution used for this project is irrelevant in terms of requirements, given that it is only intended to host the test web-shop for SPHERE.IO, and both platforms promise the same level of quality. 

Development

In spite of that, it is wise to choose the most likely option the future developers will use, so that it is tested beforehand.

uncertain

While Cloudbees also offers integrated tools to support development of Java projects, Heroku is a much popular alternative with support for several programming languages and a wide range of plugins, thus becoming a preferable option for the project. Unlike SPHERE.IO, Heroku is scalable only under demand. 

Development

Unlike SPHERE.IO, Heroku is scalable only under demand.

Development

Figure 4.1 illustrates the physical architecture of the system.

uncertain

As appears in the diagram, any request to a Heroku deployed web application is first processed by one of the many platform’s reverse proxies.

Development

The reverse proxy forwards the request to a HTTP cache layer, which returns the page if it is cached, otherwise forwards the request to the corresponding web application [Rob11]. 

Development

The communication between the web application and the SPHERE.IO backend is always held with HTTPS as a requirement of the e-commerce platform. 

Development

Instead, the protocol of the requests between the client and the web server are decision of the developer.

Development

For this project the most reasonable option would be to use HTTPS whenever customer data is being transferred. 

Development

This is typically the case of the checkout process, as well as any time the customer is logged in. 

uncertain

4.2 System Logical Architecture

uncertain

The logical architecture of the system is designed after the MVC (Model-View-Controller) architectural pattern, which is widely used in web applications design

Development

Its use in this project is  required, since MVC is the architecture pattern followed by Play Framework, the web  framework on which SPHERE.IO Play SDK has been developed.

Development

As the name suggests, the system logic is divided into three components: Model, View and  Controller. 

Development

As a rough definition, the Model manages business logic and domain data, the  View is responsible of displaying the information, and the Controller is in charge of changing  Model and View accordingly to the user input.

Development

The specific MVC design of the current system is shown in Figure 4.2 below

Development

One of the particularities of this design is that SPHERE.IO Play SDK is the main component of the Model, since it controls all the domain data of the application, as well as most of the business logic. 

Development

Only some business rules are added to the Model in order to validate form input coming from the user, before sending this data to SPHERE.IO Play SDK, as well as some external functionalities such as email sending and online payment. 

Development

When the request reaches the web application server, a routing system analyzes the HTTP request and invokes a particular action of the corresponding controller

Development

Then the controller interprets all required input parameters coming from the user and requests the appropriate changes to the model. 

Development

In the model, SPHERE.IO Play SDK executes the request, which usually involves communication with the SPHERE.IO backend in order to create, read, update or delete (CRUD) some of the stored data.

Development

Once the model finishes processing the request, the controller selects the appropriate template and sends all information related to the current request to the view.

Development

With this information and some other obtained directly from the model, the view generates a HTML document that is sent back to the client via a HTTP response.

Development

With this design, a new whole web page must be loaded from the server every time the user wants to interact with the system.

UI design

This is known as a “thin client” design, because all the logic is located in the server, leaving the client with the only task of rendering the web page. 

Development

In comparison with that, a “fat client” hosts all the logic of the system; hence Controller, View and Model are located on the client side, leaving in the server just those parts of the Model responsible for the security and management of persistence.

Development

A fat client allows the user to interact with the system while never reloading the web page, only updating those specific components of the page that changed during the interaction. 

Development

This behavior enhances the user experience, because the user can continue interacting with the system while operations are taking place. 

uncertain

Information can also be presented in an incremental way, so that the user can start interacting with some elements of the page while further information is being retrieved

uncertain

Another important fact is that traffic between the client and the system is reduced to simple data with no presentation information, which speeds up the communication with the system and decreases network use.

Development

While a fat client solves some external design issues, it also creates several technical problems. 

Development

Since the web page is never reloading, the browser can no longer control the routing, caching or history management of it. 

uncertain

Therefore it is the responsibility of the system to replace those functionalities that the browser is unable to perform. 

uncertain

These technical problems can be considered a too expensive price to pay in order to improve the user experience. 

uncertain

The amount of resources needed to implement a reliable system with a pure fat client is several times higher than the equivalent with a thin client. 

Development

Moreover the complexity of the code is also very significant, which makes this design not suitable for a template that must be understandable and easy to learn. 

Requirements

A mixed approach between a fat and a thin client can be the solution to improve the user experience without giving up on the browser logic

Development

The website can be divided into different contexts that offer the user some common functionalities.

uncertain

Between contexts the web page is fully reloaded, while operations within the contexts only update some parts of the page [Con13].

UI design

By way of example, each product detail page is a different context, but adding a product to the shopping cart only updates the mini-cart displayed, while the user never leaves the page.

UI design

In order to facilitate understanding of the logical architecture of the system, its design has been divided into two different diagrams: the one corresponding to the scenario between contexts and the one displaying the scenario within a context.

uncertain

The former has already been explained before, so the following explanation will focus on the differences and characteristics between both scenarios. 

uncertain

Every time a new context is loaded or the user interacts with the web page in some way, an event is fired by HTML DOM.

UI design

The controller on the client side can handle these events, in which case it gathers the required information and requests the client-side model to validate this information in order to avoid unnecessary calls to the server. 

Development

If the validation was successful, the controller sends the corresponding HTTP request to the server, which is analyzed by the routing system and handed over to a controller action the same way as before. 

Development

As well as before the controller requests the appropriate changes to the model, but this time when the model finishes, the controller generates JSON data using the information related to the current request coming from the model. 

Development

This JSON data is sent back to the controller located on the client, which in turn selects a template and sends this data to the view. 

Development

With that, the view generates a HTML fragment that uses to replace the corresponding component on the web page. 

Development

4.2.1 Description of Used Technologies

Uncertain

The current project has several technologies that are fixed by the requirements, starting with SPHERE.IO Play SDK.

Development

This SDK is designed to be used with Play Framework, and specifically with the Java language version.

Development

Besides the framework has a significant influence on several other server-side technologies as well, depending on the support it provides. 

Development

On the other hand, the payment platform needs to be carefully chosen, because it has inevitably a great impact on the template reusability and the analysis of the platform.

Development

All client-side technologies need to be selected, specially the templating solution in the view component. 

Development

Furthermore, given that maximizing developer experience (i.e. user experience applied to developers) is one of the main requirements of the project, this system needs technologies to help organizing and simplifying the code, particularly complex because of the logical architecture design. 

Requirements

Figure 4.4 above illustrates the use of technologies in each component. 

uncertain

As it shows, Play is the web application framework, that uses the programming language Scala in the templates, and Java in both model and controllers. 

Development

In the model SPHERE.IO provides the main commerce business logic of the system, while Optile supports the payment functionality. 

Development

Additionally, LESS and CoffeeScript are used server-side to generate CSS and JavaScript files, respectively. 

Development

The server is using HTML5 and JSON files to send information to the client. 

Development

The logic of the client side is supported by jQuery and the templating system is implemented with Handlebars. 

Development

A description of each chosen technology and the characteristics that influenced the decisionmaking are detailed below. 

uncertain

4.2.1.1 SPHERE.IO

Development

SPHERE.IO is a cloud-based commerce platform, aimed to unify e-commerce data in a single  place where any kind of external system can access this information. 

Development

These external systems are typically web-shops but can actually be any type of application, even those not related to ecommerce. 

uncertain

SPHERE.IO provides a platform to store and process all this data according to commerce business rules, while at the same time offers several ways to access it. 

Development

The primary entry point to the backend is provided by a RESTful API, that offers an interface for programmatic access to the data and associated functionality. 

Development

The API services are using JSON to communicate, always over HTTPS, with previous authorization using OAuth2.

Development

Although it is actually the core of the platform, its direct use might be tedious for slightly complex applications. 

uncertain

That is the reason why it is recommended to use client libraries and SDKs to communicate with the API, and so improving the development experience.

Development

The SPHERE.IO team chose Java as the first programming language to have a client library due to its versatility. 

Development

This library is open source, as it is intended to be improved or used as a reference to build other libraries by the developer community.

Development

In order to provide a better environment to build websites, a SDK was built on top of the client library: the SPHERE.IO Play SDK. 

Development

It allowed to adapt the Java client library to the processes and structure of the Play Framework. 

Development

A command-line interface (CLI) is also available, especially aimed for managing SPHERE.IO user accounts and projects from a command-line shell. 

Development

It is also necessary to use the CLI in order to manipulate and query data in batches or for automated jobs, such as importing products into SPHERE.IO. 

Development

As opposed to the API, the CLI is not using OAuth2 since all operations are done under a user account.

Development

So far all the tools for accessing and managing the backend data were focused on developers, but merchants have also the possibility to view and update the data using a web application called Merchant Center. 

Development

Besides that, merchants can also export and import data between SPHERE.IO and other external systems using elastic.io11 as an integration platform. 

Development

4.2.1.2 Optile

Development

Optile is a payment platform that allows to access a set of heterogeneous payment methods and providers (e.g. credit cards, direct debit, PayPal) under a common interface.

Development

Once the web-shop has the platform integrated, the set of payment options can be extended or reduced without any extra implementation effort.

uncertain

Optile has five different main levels of integration: redirected, hosted, half-native and native with and without PCI.

Development

These are implemented one on top of the other without losing the previous implementation, that way one can go back to lower levels very easily. 

Development

The first level is the universal redirect, where the customer is completely redirected to the payment platform and there he enters his payment data. 

uncertain

In the second level that form is hosted in the system via a HTML frame or JavaScript.

Development

With the third level the system is in charge of querying the platform about the payment options and display them, but once the user selects one he is redirected to the platform to provide the payment data.

uncertain

The fourth level displays both payment options and forms, taking care of submitting the forms to the platform. 

Development

The last level requires the system to be PCI compliant, because it gathers the payment data and queries the platform to charge the customer with the provided data. 

Development

In opposite to traditional payment platforms, the successful integration of Optile will attest that this web-shop supports a wide range of payment methods and providers, as well as multiple different ways of integration. 

Development

It is also a good choice for developers, who will have a system with several online payment methods already implemented. 

uncertain

Optile first integration can become a little bit tedious, but its flexibility will be profitable for this project. 

Development

A valid alternative is Paymill, a popular payment solution which characteristics are completely opposed to Optile: the integration is very fast and easy, but the payment providers offered are limited to credit card and direct debit. 

Development

Also the customer is never redirected to the payment server, yet there is no need to be PCI compliant. 

uncertain

The reason is that the payment form is never submitted, but its data is sent to the payment server via a JavaScript library, returning a token in exchange that the system can use to charge the customer from the server side. 

Development

Nevertheless the selected solution is Optile, because its implementation will benefit more the project than Paymill. 

Development

"4.2.1.3 Play  Framework"

Development

The use of Play Framework comes as a requirement to test the suitability of SPHERE.IO Play SDK, which was build to create web-shops using this specific framework. 

Development

Play is an open source web application framework that was first released in 2007 and written in Java. 

Development

In 2012 a second release was announced, with a core completely rewritten in Scala.

Development

This is precisely the version that SPHERE.IO Play SDK works with.

Development

This second version of Play uses Scala in its web template system.

Development

Projects in Play are built and deployed with SBT, a build tool for Scala and Java projects, allowing developers to choose between these two programming languages in order to implement the logic of their web applications. 

Development

Despite this, currently SPHERE.IO Play SDK is supported only in Java projects. 

Development

Play follows the MVC logical architectural pattern and is completely RESTful, which means amongst other things that is stateless, unlike other Java frameworks. 

Development

It was also designed to support full asynchronous HTTP programming, to serve long-lived requests without tying up other threads. 

Development

Play also includes the Jackson library to manipulate JSON data and native support for the software testing frameworks JUnit and Selenium. 

Development

Moreover it also has a compiler for CoffeeScript and LESS, two programming languages that compile into JavaScript and CSS respectively. 

Development

4.2.1.4 CoffeeScript

Development

CoffeeScript is a programming language that compiles into JavaScript, adding syntactic sugar to greatly improve the developer experience. 

Development

The new syntax provides a better readability of the code and helps developers to write complex scripts much more easily.

Requirements

The increased readability of the code goes along with a decreased number of lines compared to the same code in JavaScript, around one third fewer lines. 

Requirements

Another interesting feature is an additional syntax to use JavaScript’s native prototyping as a class-based system, making object-oriented programming with JavaScript less complex, particularly when it comes to inheritance.

Development

Improving developer experience is a priority in this project, so CoffeeScript will contribute to make client-side code easier to understand and modify.

Requirements

It will also be considerably helpful with the development of the JavaScript code, which is pretty complex due to the logical design of the system.

uncertain

Therefore its use is very appropriate, especially since a CoffeeScript compiler comes included in Play Framework. 

Development

4.2.1.5 LESS CSS

Development

Similarly to CoffeeScript, LESS is a language that compiles into CSS. 

Development

But unlike CoffeeScript, LESS does not modify the syntax of CSS, but only extends it with dynamic behavior, such as variables, operations and functions.

Development

This makes LESS very easy to learn and converts a simple CSS-based file into a powerful dynamic stylesheet. 

Development

LESS will allow to better organize the stylesheet of the web-shop, thus facilitating a swift development, fast edition and easy understanding of its code. 

Development

Although there are other CSS preprocessors like the popular Sass, the provided functionalities are quite similar and Play Framework already comes with a native support of the LESS compiler. 

Development

4.2.1.6 jQuery

Development

jQuery is a very powerful and fast JavaScript library that allows to easily do DOM scripting (i.e. HTML elements manipulation and event handling), perform animations and simplify the use of AJAX programming; altogether very necessary in this project. 

Development

The main alternatives, such as MooTools or YUI Library, are also very satisfactory solutions in the mentioned areas, with no significant differences. 

Development

The final choice of jQuery has been mainly determined by the fact that it has the largest community amongst the options. 

Development

4.2.1.7 Handlebars.js

Development

Handlebars is the web template system used in this project to manage client-side templates. 

Development

It is a JavaScript implementation of the platform-independent Mustache project, that allows to render input data in a template using a very clean syntax. 

Development

Mustache has a so-called logic-less template syntax because there are no explicit control flow statements, all needed logic comes exclusively from the data in the form of booleans, arrays or lambdas.

Development

On the contrary Handlebars templates are compiled, allowing to define helpers to reuse code for presentation. 

Development

It also comes with built-in helpers to control the default flow of the template, such as loops or conditional statements. 

Development

Handlebars comes also with better support for paths to access the data.

Development

In short, this solution makes easier to implement templates than Mustache while still keeping logic separated from presentation. 

Development

There is another project, Dust.js, with the same strong points as Handlebars and with useful additional features like template composition

Development

There is another project, Dust.js, with the same strong points as Handlebars and with useful additional features like template composition

Development

During the last year LinkedIn has been contributing actively to a separated Dust.js project that the company is using for its website [Bas12]. 

uncertain

Regardless it has been considered that Handlebars is a safer option, since the additional features are not indispensable for this project. 

Development

4.2.2 External Design

uncertain

The external design of a system requires the developer team to work closely with a designer team.

Development

While the designers are in charge of creating the interface and aesthetic design, the other external design areas of the system need a more technical approach.

Development

These areas consist of the navigation and architecture design, as well as some parts of the content design. 

uncertain

All these aspects are covered by the User Experience (UX) Model explained here.

UI design

It describes, in particular, how the dynamic content will be structured and organized in different screens, and how the user will navigate amongst those screens to reach a particular goal.

UI design

For this project, the designer team together with the developer team decided to implement a layout structure and behavior inspired on different web-shops with innovative design, always focusing on offering the user a smooth interaction with the system

uncertain

Each screen is going to be  presented and described with wireframe prototypes, and then the storyboard sequence and  navigational paths will illustrate the connections between those screens.

UI design

4.2.2.1 Display products

Requirements

Product listing is the first functionality that a customer uses when arriving at the web-shop and the one he will be using for longer periods of time, so it needs to have a comfortable way to display and paginate the products

UI design

At best, traditional web-shops usually have very rigid ways of listing products: pagination consists of an interface that allows to select the page and the amount of products per page, while display options let the user select between a list or a grid type of view

UI design

So instead of showing a traditional shop catalog, it was considered a better option to let the products flow freely through the web page, using all the width and height possible to show at once the maximum amount of products to the user (Figure 4.12)

UI design

On the other hand, the pagination needs to be natural without losing already viewed products, so when the user reaches the bottom of the page new products should appear automatically under the previous ones. 

UI design

The product thumbnails, besides price and name, will be showing a picture of the product and the different color variants. 

UI design

The selected variant will be highlighted, and when hovering a different color the thumbnail will be updated with that variant information, such as picture and price, if different. 

UI design

The thumbnail will also include a button to add the selected product variant to the shopping cart. 

UI design

In case the product has different sizes available, when hovering the button a list of the different sizes will be shown, so that the user can select the desired size he wants to add to the cart.

UI design

When clicking on a product thumbnail the user will be redirected to the product detail of the variant he had selected (Figure 4.13), if any. 

Use Case

There he can select any other color variant, in which case a new page will be loaded in order to update the URL, to let the user share the product URL that points to this particular color. 

Use Case

He can also select a different size, but in this case the page is not reloading, as it was considered that the user does not have a need to share the exact size.

Use Case

Below one can add the selected product variant to the cart, optionally indicating the exact quantity.

UI design

The header contains a mini-cart and the login panel throughout the website.

UI design

In any product list or product detail page, the header also contains the categories and subcategories of the shop to let the user filter products by category.

UI design

The rest of the pages should contain a button to allow the user go back to the last category or product he visited. 

UI design

When scrolling, the header is always kept at the top of the page.

UI design

Below the header, a breadcrumb is showing the current category path

UI design

Whenever a product is added to the cart, the mini-cart located on the header appears for a few seconds, to let the customer know that the product was added successfully.

UI design

At any time the user can see again the contents of his shopping cart when hovering the cart button on the header, that will be closed automatically when moving the cursor away from the mini-cart. 

Use Case

Below, Figure 4.14 and Figure 4.15 presents the storyboard sequence and the navigational paths, respectively, of the screens just described. 

UI design

In the storyboard sequence it is shown how the same interactions defined in the sequence diagrams of the specification are performed through the different screens. 

UI design

This connections are also captured in the following navigational paths diagram.

UI design

The resulting screens and navigational path diagram, besides the connections between screens, shows the detailed content of each screen. 

UI design

The screen for listing products displays the selected filtering options and contains a single form to change them. 

UI design

It also has the name of the current category and the list of matching products, with their different variants for color and size.

UI design

This screen has an option to add a product to the cart, while the product detail page has a form to let the user specify the quantity of items he wants to add. 

UI design

Both screens renders the category tree so that the customer can list all products from a particular category at any moment. 

UI design

4.2.2.2 Purchase Products

Requirements

In order to start the checkout process, the user will first access the cart detail page by clicking on the cart button.

Use Case

This page shows the items and their details, along with the possibility to  remove them or change the number of units of each item (Figure 4.16). 

UI design

Both actions are performed without reloading the page, just updating the contents of the shopping cart and the pricing details accordingly. 

UI design

The checkout page can be accessed from both mini-cart and cart detail page. 

UI design

The checkout page is probably one of the least frequented pages of a web-shop, but it is for sure the most important when it comes to user experience. 

UI design

The customer needs to feel he has control of the flow and that he is able to quit at any time. 

uncertain

The checkout needs to be a secure and robust environment to the user. 

Requirements

Traditional web-shops usually reload when moving from one checkout step to the other, and it can be sometimes difficult to change the data of a step that is not immediately before the active one.

UI design

In some cases it is also hard to know what changes are modifying the price or to review what was entered on previous steps.

uncertain

All these issues are affecting negatively the feeling of control the user has.

issues

For this design it was considered a good idea to display all the steps throughout the page as sections that can be expanded, so that the user modifies them (see Figure 4.17). 

UI design

Once edited, the section closes again and displays a summary with the selected options. 

UI design

Every change automatically updates the pricing details that are always shown at the bottom of the page.

UI design

As a way of guiding the customer through the checkout process, the user can only open new sections sequentially. 

UI design

Also when a form is still not available due to missing requirements (e.g. shipping method cannot be displayed until shipping address is set) a message will be shown instead until the requirements are met.

UI design

The checkout is divided into three steps: first a cart summary, to verify the items are correct; second the shipping information, to determine where and how the goods are being delivered; and third the billing information, to select the way the products are being paid. 

uncertain

Both shipping and billing sections have on the left side a form to set the postal address and on the right side the shipping and payment options, respectively.

UI design

When the customer is logged in, his address book will appear on the right side, allowing him to select one of his addresses, which data will then be copied to the corresponding address form. 

Use Case

The storyboard sequence from Figure 4.18 is showing how this checkout process is distributed with the presented screens.

UI design

Below in Figure 4.19, the screens and navigational paths diagram expose that all screens have almost the same data, such as a set of line items and some pricing details, while the checkout page and the order summary have also a billing and shipping address, all them with different multiplicities. 

UI design

The cart has forms to update line items, as many as line items are in the cart. 

UI design

The checkout is also composed of different forms, one for each element that the customer must fill, to allow saving each element individually. 

UI design

"4.2.2.3 User management"

Requirements

Before attempting to access his profile page, the user needs to identify himself to the system. 

Use Case

This is done in the login screen, a page that also contains a form to register into the system (see Figure 4.20). 

UI design

In case the user forgot his password, the login form contains an option to recover it, which renders a modal window where an email address is requested when the option is clicked. 

Use Case

Submitting this form will send an email to the user with a new URL, that redirects to the same login page but with a different modal window to enter a new password. 

Use Case

Once the password is submitted the modal window closes, thus showing the login form again to allow the user enter his new credentials. 

Use Case

The user profile is a single page with sections to change user data, password, manage the address book and view the list of orders (see Figure 4.21). 

UI design

The latter consists of some stockable sections, each one containing all information about a particular order, such as the products purchased, the price details and all shipping and billing related information. 

UI design

When clicking on a section, this one expands showing its contents, while all other sections remain closed. 

UI design

The address book is the only section with a slightly complex design. 

UI design

This component has a list of existing addresses on the left and an empty form on the right to add a new address (Figure 4.22). 

UI design

When the user selects an address the form changes into edition mode, highlighting the address and copying its data to the empty form. 

Use Case

A button at the top allows the user to return the form to its initial mode.

Use Case

Whenever the user adds, updates or removes an address, the list of addresses is updated accordingly. 

Use Case

Again, the specification sequence diagram is adapted to the given design, illustrating the different screens that participate in every interaction in the check order top-level use case (see Figure 4.23).

UI design

Figure 4.24 below shows the screens and navigational paths diagram, displaying every screen component that belong to the customer profile screen, each with its own data and forms.

UI design

4.2.3 Internal Design

Uncertain

After representing the external design of the system, every diagram of the UX Model needs to be adapted to the chosen technologies. 

uncertain

An internal class and sequence diagram are resulting from this process, showing the communication between each component. 

uncertain

These diagrams are done with the Web Application Extension (WAE) to UML, which allows to represent every significant element of the web presentation layer with the UML modeling language. 

uncertain

In this project, the new class stereotypes of WAE enabled to represent server-side pages, client-side pages, forms and script libraries; every class with its own attributes and methods.

uncertain

There are also new association stereotypes to represent the different ways of communication between elements. 

uncertain

These can be, amongst others, a common link with parameters (link), a form data submission (submit), a forwarding of the request to another element (forward), a generation of HTML output (build) or an import of a JavaScript file (script).

uncertain

Internal design diagrams can become quite complex when trying to represent all files that participate in a use case, particularly when applying some design patterns. 

uncertain

For this reason, in this section only those diagrams that illustrate some special behavior or structure are displayed, simplifying any characteristic that is later described in the following sections, such as design patterns that apply to all use cases.

Document Organisation

The internal class diagram in Figure 4.25 represents the whole browse catalog top-level use case. 

uncertain

It is worth noticing that usually a client page links first to a server page, which then forwards to a server page with a “scala” extension. 

Development

The first server page symbolizes a file in the Controller component, while the second corresponds to a Scala template from the View, which builds the client page. 

Development

An exception to this rule appears within contexts, when the client page asynchronously makes a request to the server. 

uncertain

The response is simple data, so no HTML output is built, and it is the client page itself which updates its content with the information sent via forward parameters. 

uncertain

The methods that allow to update the information from the client page are always coming from the JavaScript files, but generally are represented as methods from the client page.

source code

Only exception appears when the same method is shared between two pages, in which case it is left in the script for simplicity [Oli10].

source code

So an example of this particular behavior can be observed when adding a product to the cart from a product page or a product list page. 

uncertain

The server page that updates the cart sends to the mini cart component all the information related to the shopping cart contents.

Development

With this data the JavaScript in charge of the cart updates only the mini cart component with the new information. 

Requirements

Another example is the functionality to load more products when scrolling to the bottom of the page

UI design

In this case also the corresponding sequence diagram is presented (Figure 4.26) to observe in detail how the components are behaving. 

uncertain

First, the customer navigates to the SelectCategory server page, which requests to SPHERE.IO the list of products for a particular category.

uncertain

This server page forwards all necessary information to the corresponding view, which creates the entire client page and sends it back to the customer. 

Development

Then when the customer scrolls to the bottom of the page, the load more products method is called from the client page, which starts an asynchronous request to the server while the control is given back to the customer.

Use Case

In this request the script itself communicates with the server page ListProducts, which again makes a request to the model, this time asking for the next page.

Development

The resulting data is sent to the client page, that renders and appends a new Product List component with the received products.

Development

Figure 4.27 below is the internal design class diagram for updating and removing line items from the cart. 

uncertain

The update functionality requires a form where the customer specifies the new quantity, while removing is just a direct link. 

uncertain

Both actions end up in the server page for updating the cart, which forwards the new cart information to the cart page. 

uncertain

Figure 4.28 below presents the internal sequence diagram corresponding to the update item in cart use case, although the diagram corresponding to the deletion is very similar.

uncertain

The initial process to access the client page is the same as any other use case: the customer navigates to the server page, which forwards the information to the template, which builds the client page. 

Use Case

Unlike the use case for removing line items, when updating them the customer is filling a form. 

Use Case

But the form does not have a submit button, instead it is automatically submitted when the user changes the quantity value.

UI design

That is the reason why after filling the form the page is calling the update line item method, which asynchronously submits the form to the server page UpdateCart. 

uncertain

As in any other background form submission in this project, the server page requests to the model the corresponding change and the related information is forwarded to the initial client page.

Development

From this page is called the update price details method, which in fact builds several page components and replaces with them the corresponding elements displayed in the page. 

uncertain

The next two diagrams illustrate together the place order use case, being Figure 4.29 focused on the checkout page, and Figure 4.30 on the order creation and display of a summary. 

uncertain

The first diagram has several forms, one for each element to be modified individually: the shipping address, the shipping method, the billing address and finally the payment form. 

uncertain

The payment form does not appear in the diagram because its submission is not directed to this system, but to the payment platform, as it will be described in the corresponding sequence diagram

uncertain

In any case, it would only consist of a submit button and a dynamic payment form loaded with the data coming from Optile. 

UI design

As the actual content is unknown, it was considered best to leave it out from the diagram. 

uncertain

All other forms from the diagram are submitting in the background as the previous example. 

uncertain

In every asynchronous call, the updated information regarding the current checkout state is forwarded to the checkout page. 

uncertain

On the other hand, some of the data needs to be requested explicitly to the server, such as the list of shipping methods or the address book of a registered customer, to avoid performing repeated unnecessary calls to the SPHERE.IO backend. 

Development

The second diagram follows a simple design: the moment the customer is redirected from the payment platform back to the system with a successful payment, the server page creates the order and forwards all its information to the template, which in turn creates a page with a summary of the order to be displayed to the customer.

uncertain

In contrast, the internal sequence diagram of the order creation is much more complex than the class diagram (see Figure 4.31).

uncertain

Once the checkout form is filled and the customer decides to submit it, the data is sent directly to the payment platform in order to avoid being PCI compliant. 

Use Case

The platform proceeds charging the customer and then redirects him to the system. There the order is created and the order summary is displayed. 

Use Case

The payment platform redirects the customer to a different server page based on whether the charging operation was successful.

Use Case

The order is therefore only created when the customer is redirected to the successful server page. 

Use Case

But this system would easily lead to fraud, because the user could try to access the page directly without being charged. 

issues

To solve this issue, the order is created but always with a pending payment status. 

Requirements

The only possible way to update the payment status from the web-shop is to access the NotifyPayment server page, which access will be limited to the payment platform (see Figure 4.32).

Development

Optile requires this notification request to update the payment status of a certain order, something necessary when there is a change in the payment. 

Development

This can easily happen when using PayPal, because the payment needs to be approved first, therefore changing multiple times of status during an undefined period of time.

Development

4.2.4 DESIGN OF THE MODEL COMPONENT

Uncertain

As described at the beginning of the section System Logical Architectural 4.2, the logic of the model component is largely located in the SPHERE.IO Play SDK, which contains all the commerce logic and allows to access all data stored in the e-commerce backend. 

Development

The Sphere class shown in the diagram below (Figure 4.33) is precisely the entry point for SPHERE.IO.

uncertain

There is also a Payment class, a small library that will help to communicate with the Optile API, that requires the messages to be sent using XML

Development

As explained before (see section 4.2.1.2), Optile needs to be implemented in an incremental way, reason why the library can effortless  cover all five levels of integration, thus allowing developers to easily switch to the level it fits  best for them.

Development

The system also requires a class to send emails through any email system of preference. 

Requirements

The Mail class will cover this functionality, as long as the SMTP17 details of the email system are provided.

uncertain

Given that Heroku does not provide an internal SMTP server, the deployed version of this project will need to use an external server like Mailjet, a cloud emailing platform that offers several features that may be of interest for potential clients.

Development

The Model component is also containing different helpers, where some particular logic of this web-shop is located. 

Development

The ControllerHelper is composed of methods that allows to abstract some common logic that is used in the Controller component (i.e. logic to handle and display messages and errors) or data coming from SPHERE.IO requiring some previous manipulation before it is used (i.e. get default category of a product or get address book of the current customer). 

Development

On the other hand, the View Helper is a common design pattern that allows to separate logic that otherwise needs to be integrated in the template, in this project applied with the ViewHelper class.

Development

Although templates in Play Framework enables to use all the potential of the programming language Scala, it is a good practice to keep complex logic out of the templates. 

Development

All this logic is then placed in these helper classes and called from the views as necessary.

Development

Lastly, there are a group of classes related to the web forms and the payment information received by the system (see Figure 4.34).

uncertain

They handle all the server-side validation for every parameter and may also provide helpful getters and setters to easily convert model data into form data, and vice versa (e.g. an Address class instance would be converted into the appropriate form fields street, city, country, etc.) 

uncertain

These form classes also host the methods generating the different content that must be sent back to the client in relation to the result of the form submission. 

uncertain

For example, when updating a line item from the cart, a success response contains a message for the user and all the shopping cart related information.

UI design

This related information is generated with some other methods located in the forms as well, that convert a model class instance into JSON data. 

source code

Due to the design of the system, the client side has also some important elements from the Model component.

Development

Although the separation between Model and Controller is not properly defined in the client side, mainly because of the simplicity of the business logic located there,  there are also some client-side classes that are dedicated mainly to processing and validation  purposes (see Figure 4.35).

Development

On the one hand there are some classes in charge of different elements that are affected by multiple operations throughout the web-shop, such as the mini cart and the pricing detail of a cart. 

uncertain

Aside from the methods to control the behavior of the elements, there are methods that allow to replace the page component data with some JSON data fetched from the server. 

source code

On the other hand there is a Form class that gives support to all forms of the system, by validating, displaying messages, marking invalid fields and managing AJAX calls when submitting.

uncertain

4.2.5 Design of the View Component

