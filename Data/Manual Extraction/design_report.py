# -*- coding: utf-8 -*-
"""
Created on Tue Jan 22 11:34:30 2019

@author: Lenovo
"""




sections = [{'h1': '1. Introduction', 'pages': [4,5], 'paragraphs':[['Grader++ is a code evaluation system we plan to develop in aid to instructors and teaching assistants.',' Most of the time, instructors’ method of grading students codes involves steps that can be automated by a software system.',' For example, an instructor firstly compiles student’s code and checks whether there is a compilation error, then he/she proceeds by checking if the code has memory leaks, and tries a few test cases and compares output with students solution.',' Steps like these can be easily automated by a software and reduces the time it takes for instructors to grade code submissions.'],['There are problems automating these kinds of tasks.','Students might submit malicious codes which can be caught by instructor by scrutinizing the code.',' Automating this process and handling dangerous codes is difficult.',' We plan to make grader++ secure by using technologies like containers.',' Also we will make it extendible, since every course, and even individual homeworks, needs different evaluation steps.','Another planned capability for our system is working fast even under a huge work load, because (for example) a course could be taken by a lot of students, and it is possible that a significant amount of students will submit their code at the last minute and it will create a lot of load on the system.','In this kind of situation, system should be able to handle evaluating process very efficiently so that students can see the analysis of their code. '],['Grader++ has two parts: Core part and UI part.','Core part will be an extendible system composed of evaluators, evaluating submissions concurrently.',' UI part will give ability to instructors to add homeworks to the system and students to submit their code.','Core part will be a restful api server, accepting task descriptions and submissions.',' UI part will interact core part through http requests and will have a web frontend in which instructors and students could interact core part with ease.',' Separating core part from UI will enable us to easily extend our system and will enable us to use more than one server, so that UI part will be accessible under heavy load.  ']], 'sub-sections': []},
            {'h1': '2. Requirements Analysis', 'pages': [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25], 'paragraphs':[[]], 'sub-sections': [
                    {'h2': '2.1 Overview ', 'pages': [5], 'paragraphs':[['As the group #9 we decided Grader++ for our project’s name.',' We aim to develop an automated grading service.',' This service can be useful for a lot of different purposes, however we decided to develop Grader++ for helping with grading programming homeworks, and for helping students with the development of their programming skills by providing them with analysis tools.',' We want to make a service which is somewhat similar to hackerrank and codeforces.',' We decided to use JAVA for implementation. ','There is a brief information about Grader++ in “Introduction” part of this report.',' After short description of the game, there is an explanation of why we have chosen to work on Grader++.',' In this report, requirements of the project will be given under two headings: Functional Requirements and Nonfunctional Requirements. ','System models of the service will also be described in detail.',' System models section includes domain analysis, use case analysis, sequence diagrams, state and activity diagrams. ','After System models section, detailed description of Grader++ features will be provided. ']], 'sub-sections': []},
                    {'h2': '2.2 Functional Requirements ', 'pages': [5,6], 'paragraphs':[['Register',' ● TA and student will register in standard way with generating a unique username and password',' ● Instructor must contact with admin to create an instructor account. '],['Login ','● User name and password required log-in mechanism. ',' ● Login system is common to for all types of users. (TA, instructor, student)  '],['After Login',' ● Student should get new tasks from the courses that he subscribed.',' ● Student should be able to generate a new submission for a selected task',' ● Student should be able to view old submissions for a particular task ','● Student should be able to subscribe or unsubscribe from a course.',' ● Instructor should be able add or delete course',' ● Instructor should be able to add or delete a task ','● Instructor should be able to assign a TA for a course. ','● Instructor should be able see old submissions',' ● TA should be able to edit a task that he assigned ','● TA should be able to see old submissions']], 'sub-sections': []},
                    {'h2': '2.3 Non-Functional Requirements', 'pages': [6,7], 'paragraphs':[['User-Friendly UI ','● Basic menu with a single page application',' ● No recursive paths in application'],['Performance ','● Make a queue of submissions to divide load',' ● Lightweight single page application UI to prevent unnecessary loads '],['Security',' ● Disable to see others code and submissions ','● Disable to see closed tasks ','● To create instructor account admin is required '],['Robustness ','● Check submitted files for malware ','● Check submitted code for malware ']], 'sub-sections': []},
                    {'h2': '2.4 Constraints ', 'pages': [7], 'paragraphs':[['● The user interface should be in the web platform.',' Thus, the user can interact with the system through a web browser.',' ● The web-based user interface should be built with Java and by following the MVC (Model-View-Controller) principle in order to handle the future modifications quickly.',' ● The back-end mechanism, the essential part of the code evaluating system should also be implemented in Java, and if needed C++. ','● The live server machine which will serve to code compiling, evaluating and grading, should use Ubuntu 12 or above.']], 'sub-sections': []},
                    {'h2': '2.5 Scenarios ', 'pages': [7,8,9], 'paragraphs':[['In this section we provide some specific scenarios which will help us derive use case model of the overall system. ']], 'sub-sections': [
                            {'h3': '2.5.1 Scenario Name: addCourseToSystem ', 'pages': [7,8], 'paragraphs':[['Participating Actors: o​ zgur:Instructor',' Flow of events: ','1) Ozgur selects “Instructor” as the user type on the login page',' 2) Ozgur types username and password, and clicks login button.',' 3) Web client provides the Instructor Home Page for viewing.',' 4) Ozgur clicks “add course” button.',' 5) Client provides the add course page and waits for ozgur to confirm the course addition.','6) Ozgur fills the forms for “course name” with “cs202”, adds a course description, and confirms the creation of coruse by clicking “create course” button. ','7) Client provides ozgur with insctructor home page. ']], 'sub-sections': []},
                            {'h3': '2.5.2 Scenario Name: ​ deleteCourseCS202 ', 'pages': [8], 'paragraphs':[['Participating Actors: o​ zgur:Instructor ','Flow of events: ','1) ozgur selects “Instructor” as the user type on the login page',' 2) ozgur types username and password, and clicks login button. ','3) Web client provides the Instructor Home Page for viewing.',' 4) ozgur selects the course cs202 to delete it from the system. ','5) ozgur clicks “delete course” button.',' 6) Web client provides a pop-up alert asking ozgur to confirm the deletion.',' 7) ozgur confirms the deletion by clicking the “confirm” button. ','8) Client provides the Instructor Home Page for ozgur to view. ']], 'sub-sections': []},
                            {'h3': '2.5.3 Scenario Name: ​addTaskForCS202', 'pages': [8], 'paragraphs':[['Participating Actors: o​ zgur:Instructor ','Flow of events:',' 1) ozgur selects “Instructor” as the user type on the login page ','2) ozgur types username and password, and clicks login button.',' 3) Web client provides the Instructor Home Page for viewing.',' 4) ozgur selects the course CS202 to add a task to, and clicks “add task” button.',' 5) Client shows the form page for adding a new task.',' 6) ozgur fills the required information such as “information”, “test case”, “due date”, and then clicks the “add” button. ','7) Client provides the Instuctor Home Page to ozgur. ']], 'sub-sections': []},
                            {'h3': '2.5.4 Scenario Name: ​submitCodeToCS202', 'pages': [8,9], 'paragraphs':[['Participating Actors: ​ omer:Student ','Flow of events:',' 1) omer selects “Student” as the user type on the login page ','2) omer types username and password, and clicks login button. ','3) Web client provides the Student Home Page for viewing. ','4) omer selects the hw1 of CS202 to make submission to, and clicks “submit” button. ','5) Client shows the form page for submitting code.',' 6) omer selects the code file he wants to submit from his computer, and then clicks “submit” button.',' 7) Client provides omer the Student Home Page ']], 'sub-sections': []},
                            {'h3': '2.5.5 Scenario Name: ​ viewSubmissionsForCS202HW1 ', 'pages': [9], 'paragraphs':[['Participating Actors: ​ fatma:TeachingAssistant ','Flow of events: ','1) fatma logs in to the system as a TA.',' 2) Web client provides fatma with TA Home Page. ','3) fatma selects the course cs202 and hw1 to view the status of every submission on hw1. ','4) Client provides fatma with “view submissions” page. ']], 'sub-sections': []}]},
                    {'h2': '2.6 Use Case Models ', 'pages': [10,11,12,13,14], 'paragraphs':[['This sections explains the main use cases of Grader++ in detail.']], 'sub-sections': [
                            {'h3': '2.6.1 Submit Code ', 'pages': [11], 'paragraphs':[['Use Case Name: Submit Code ','Primary Actor: Student​'],['Stakeholders and Interests: ','● Student aims to make his/her submission to the related Task of his/her Course.',' ● Submission must be received by System and put into progress of evaluation and grading. '],['Pre-condition: ​','Student must be logged in. ','Also the Course that Student is taking must have a Task. ','Post-condition: ​ ','The submission must be obtained by System and saved. ','System should evaluate the submission in terms of requirements criteria. ','Entry Condition:',' ​ Student presses the “Quick Submission” link from homepage. ','Exit Condition: ','​ Student presses the “Submit” button of the submission form. '],['Event Flow: ','1. Student selects a Task from the list. ','2. Student selects the “.zip” file which contains all the required files from “Browse” button.',' 3. Student presses the “Submit” button.'],['Alternative Flows: ','1. If Student wants to cancel submission:',' a. Presses the “Cancel Submission” button of the form. ','b. He/she returns to the Main Page. ']], 'sub-sections': []},
                            {'h3': '2.6.2 View Tasks', 'pages': [12], 'paragraphs':[['Use Case Name:​ View Tasks ','Primary Actor: ​ Student, TA, Instructor '],['Stakeholders and Interests: ','1. Student should see the details and evaluation state of the submission he/she made.',' 2. Instructor and TA should see the details and evaluation state of the submissions made by students on the selected Task. ','3. Student, Instructor, TA should see all the details of a specific Task. '],['Pre-condition: ​ ','User must be logged in. ','Post-condition: ​ -',' Entry Condition: ','​ Instructor, TA or Student presses a particular Task’s “View Submissions & Details” link which is located on a specific Course’s page.',' Exit Condition: ','​ User presses the “Return to Main Page” button.'],['Event Flow:',' 1. User should see a data table which consists of rows that each represents a submission, and columns such as submitter name, submission date, evaluation grade, the name of the Task that is submitted to etc. '],['Alternative Flows: ','1. If User wants to see the details of the submission: ','a. Presses the button at the left corner of the row of Submission.',' b. User should see the details in a new page.',' 2. If User wants to reorder the results by a column in the table:',' a. Presses the head of the column. ','b. All the rows should be reordered by the column (ascending or descending) ']], 'sub-sections': []},
                            {'h3': '2.6.3 Manage Tasks ', 'pages': [13], 'paragraphs':[['Use Case Name:​ Manage Tasks ','Primary Actor: ​ Instructor, TA '],['Stakeholders and Interests:  ','- User should be able to define a new Task and determine its qualifications. ','Also, User can assign a TA as a manager. ','- User should be able to modify a specific Task’s qualifications such as task description, grading policy, due date, required files, makefiles, test files. '],['Pre-condition: ','​ User must be logged in.',' User should be authorized to manage Tasks. ','Post-condition: ​ ','The overall changes like adding or editing a Task, should be saved to the System.',' Entry Condition:',' ​ User presses the “Task Manager” button from a particular Course’s page.',' Exit Condition: ​ ','User presses the “Return to Main Page” button. '],['Event Flow: ','A. If User wants to add a task:',' a. Chooses the “Add Task” tab from panel.',' b. Fills the required fields',' c. Clicks to the “Add” button',' B. If User wants to edit a task: ','a. Clicks to a tasks “Edit” button ','b. Makes necessary changes like changing the name, description, grading policy, due date, compiling options, adding test files.',' c. Clicks to the “Save” button.',' C. If User wants to view a Tasks submissions',' a. Clicks to the “Submissions” button. ']], 'sub-sections': []},
                            {'h3': '2.6.4 Manage Courses ', 'pages': [14], 'paragraphs':[['Use Case Name:​ Manage Courses ','Primary Actor: ​ Instructor '],['Stakeholders and Interests:','  - User should be able to define a new Course and determine its qualifications.',' - User should be able to modify a specific Course’s qualifications such as course description, course name.   '],['Pre-condition: ','​ User must be logged in.',' User should be authorized to manage Courses. ','Post-condition:',' ​ The overall changes like adding or editing a Course, should be saved to the System. ','Entry Condition:',' ​ User presses the “Course Manager” button from a particular Course’s page.',' Exit Condition:',' ​ User presses the “Return to Main Page” button. '],['Event Flow: ','A. If User wants to add a course:',' a. Chooses the “Add Course” tab from panel.',' b. Fills the required fields',' c. Clicks to the “Add” button ','B. If User wants to edit a course:',' a. Clicks to a tasks “Edit” button ','b. Makes necessary changes like changing the name, description, grading policy, due date, compiling options, adding test files.',' c. Clicks to the “Save” button. ','C. If User wants to view a Courses tasks',' a. Clicks to the “Tasks” button. ']], 'sub-sections': []}]},
                    {'h2': '2.7 User Interface ', 'pages': [15,16,17,18,19,20,21,22,23,24,25], 'paragraphs':[[]], 'sub-sections': [
                            {'h3': '2.7.1 Instructor Add Course Screen ', 'pages': [15], 'paragraphs':[[]], 'sub-sections': []},
                            {'h3': '2.7.2 Instructor Add Task', 'pages': [16], 'paragraphs':[[]], 'sub-sections': []},
                            {'h3': '2.7.3 Instructor Home Page ', 'pages': [17], 'paragraphs':[[]], 'sub-sections': []},
                            {'h3': '2.7.4 Login Page ', 'pages': [18], 'paragraphs':[[]], 'sub-sections': []},
                            {'h3': '2.7.5 Instructor View Submissions Page ', 'pages': [19], 'paragraphs':[[]], 'sub-sections': []},
                            {'h3': '2.7.6 Student Home Page ', 'pages': [20], 'paragraphs':[[]], 'sub-sections': []},
                            {'h3': '2.7.7 Student Submit Code Page', 'pages': [21], 'paragraphs':[[]], 'sub-sections': []},
                            {'h3': '2.7.8 Student View Submissions Page ', 'pages': [22], 'paragraphs':[[]], 'sub-sections': []},
                            {'h3': '2.7.9 TA Home Page', 'pages': [23], 'paragraphs':[[]], 'sub-sections': []},
                            {'h3': '2.7.10 TA Edit Task Page', 'pages': [24], 'paragraphs':[[]], 'sub-sections': []},
                            {'h3': '2.7.11 TA View Submissions', 'pages': [25], 'paragraphs':[[]], 'sub-sections': []},
                            {'h3': '2.7.12 Register Page ', 'pages': [25], 'paragraphs':[[]], 'sub-sections': []}]}]},
            {'h1': '3. Analysis', 'pages': [26,27,28,29,30,31,32,33,34,35,36,37,38,39,40], 'paragraphs':[[]], 'sub-sections': [
                    {'h2': '3.1 Object Model ', 'pages': [26,27,28,29,30,31,32], 'paragraphs':[[]], 'sub-sections': [
                            {'h3': '3.1.1 Class Diagrams ', 'pages': [26,27,28,29,30,31,32], 'paragraphs':[['Note: ','Class diagram is small and cannot readable here.',' We uploaded the bigger version of image to github.']], 'sub-sections': [
                                    {'h4': '3.1.1.a User Interface Classes ', 'pages': [26,27,28,29], 'paragraphs':[[]], 'sub-sections': [
                                            {'h5': '1.Models:', 'pages': [26], 'paragraphs':[['● User​ : ','This is a model class which represents a single user of UI.',' When a person is signed in to the system, according to the role of the actor, an instance of a child class of User (Student, Instructor or Assistant) is instantiated.'],['● Task:​ ','It represents a single task which is assigned by an Instructor.',' Holds necessary information and references to the other objects. '],['● Submission:​ ','Instantiated when a Student makes a submission to a specific Task. ','Holds the code file and necessary informations. '],['● Course:​ ','Stands for representing a Course.',' It can hold multiple Tasks. '],['● File:​ ','Represents submission files, test case files and makefiles. ']], 'sub-sections': []},
                                            {'h5': '2. Views ', 'pages': [26], 'paragraphs':[['● MenuModel:​ ','This is a class for generating user-specific menus in the interface. ','This class is inherited by other menu models which are specific to Students, Instructors, and Assistants. '],['● XHTML View Files: ​ ','These are not Java classes, but a mix of XML and HTML files.',' We have separate .xhtml files for each page in the UI.',' These files contain all the required elements in the views such as buttons, tables, input fields and etc.']], 'sub-sections': []},
                                            {'h5': '3. Controllers ', 'pages': [27], 'paragraphs':[['● LoginController:​ ',' It is a controller class which will be used to handle the authorization management. ','It holds a reference to the User object which has signed in.',' This class is also used by other controllers in order to handle authorization.'],['● PageController:​ ','This is an abstract class and inherited by other controller classes which are particular to each view (CodeSubmitPageController, MyTasksPageController, HomepageController, TaskManagerController, CourseManagerController). ','PageController functions as a bridge between views and models, and is able to manipulate all the models. ','It has references to the services so that it can communicate with our Database and Remote Server. '],['● DatabaseConnectionService:','​ User interface makes all the database interaction via this service. ','Creating, reading, deleting, updating objects in the database is done by this class. '],['● ServerConnectionService:​ ','UI connects to our remote server through this service. ','This class is used for establishing the connection between User Interface and Remote Server which can receive submitted codes and compile it, then evaluate it according to the preferences.',' This CoreDispatcher class can make all the required network requests such as connectCore, submitCode etc. ']], 'sub-sections': []}]},
                                    {'h4': '3.1.1.b Core Classes', 'pages': [30,31,32], 'paragraphs':[['Core Facade class and rest of the classes, which will together live in a standalone web server, will be accepting https requests of task submissions and will only know enough about tasks that can be used in grading the submissions. ','Core server will not know about users, and it will be stateless (It will not hold the submission results, it will just return it and forget it).',' Stateless core standlone web server gives us the opportunity to distribute it on many servers behind a load balancer and adding more servers will be very easy because of our stateless architecture.',' However it will store task definitions in the same database as UI part.',' There several classes which will fulfill the core’s task description. ','Evaluators will be runned on the submission according to given topology in task description, their log will be returned in submission object, which will be consist of evaluatorResults. ','Here is the description of core classes: ','● Core Facade: ','Core facade will be a class which will expose functionality related to evaluation of submissions to the rest of the classes in a structured manner. ','It will have access to database and worker queue, and provide syncronization between them. ','● WorkerQueue: ','Every submission on the system will be described as Worker class and WorkerQueue class will orchestrate those Worker objects. ','It will allow us to assign our resources to the tasks in a well defined behaviour and prevent overloading and system crashes. ','● Worker:',' Worker class will consist of a CoreSubmission object and an Environment object.',' When a Worker object’s evaluate method is called, it will evaluate submission in given Environment.','● Environment:',' Environment class will hold resources and access to an isolated system, in which submissions can be compiled, tested and graded Environment class will provide  a secure sandbox in which user submissions can be evaluated without interfering the system.',' Also not accessing system directly, but by a shield class will give us an opportunity to improve security features quickly without changing other parts of the code ','● CoreSubmission: ','CoreSubmission Class is similar to Submission class. ','In a way it is a proxy of the Submission class. ','However it will only hold the necessary information about evaluating the code, it will not hold any information about the student who submitted the code, or deadlines. ','● CoreTask:',' Similar to CoreSubmission, CoreTask is a proxy of Task Class. ','Again, similar to CoreSubmission, it will not hold any other information about task other than how to grade codes that submitted to given task. ','We used this two proxy classes in order to have a clean, understandable core package. ','● Evaluator:',' An Evaluator is a class that will grade the submission for a given task and return the result.',' Evaluator will work on given Environment. ','There are two types of evaluators: RuntimeEvaluator and OutputEvaluator. ','● RuntimeEvaluator: ','RuntimeEvaluator will receive shell command which will be executable over given input and output format and will produce result on them. ','There is one child of RuntimeEvaluator currently, MemoryLeakEvaluator which will tell if users submission has a memory leak given a test case.','● Result:',' Result Class will hold the overall evaluation result for a submission and a task. ','It will have necessary transformation functions which will help getting a structured response, whether to save or display it to the user.',' It will hold the list of EvaluationResult objects.','● EvaluationResult: ','Every Evaluator class will return an EvaluationResult object which will hold status about evaluation, whether evaluation is completed without any errors or not, grading and logging. ','It will also return an human readable string function. ']], 'sub-sections': []}]}]},
                    {'h2': '3.2 Dynamic Model ', 'pages': [33,34,35,36,37,38,39,40], 'paragraphs':[[]], 'sub-sections': [
                            {'h3': '3.2.1 Statechart Diagram', 'pages': [33,34,35,36], 'paragraphs':[['This diagram sho-ws the standard procedure for logging in to the system. ','This is common to for all types of users. (TA, instructor, student) '],['This diagram shows the interactions of the student in Grader++.',' Basicaly student can see his old submissions and can generate a new submission.'],['To create a new submission student must have selected a task. ','After selecting a task student could make a new submissions for the task.',' After tapping submit button, new submission screen will pop up. '],['To see the old submissions student must selected a task.',' After selecting a task student could see the old submissions for the task. ','After tapping view button, old submissions screen will pop up. '],['This diagram shows the interactions of the instructor in Grader++.',' Basicly instructor can add course, delete course, add task, delete task and view submissions.',' To delete a task instructor must be selected a task. ','To delete a course instructor must be selected a course. ','Add task and add course options will pop up appropriate screens.',' Instructor able to see old submissions.'],['This diagram shows the interactions of TA in Grader++. ','Basicly TA can edit task and view submissions.',' To edit a task TA must be selected a task.',' To view submissions TA must be selected a task.',' After selecting task TA could see the submissions for that task. ']], 'sub-sections': []},
                            {'h3': '3.2.2 Sequence Diagrams', 'pages': [36,37,38,39,40], 'paragraphs':[['After user accesses the login screen and successfully enters his/hers id and password the system will provide the appropriate homepage depending on the type of user (instructor, teachign assistant or student).',' Each user is allowed to do spesific operations on client, for example instructors can add courses to system, add tasks(homeworks) for a course, and students can submit their homeworks through client.',' Among these operations, significant ones’ sequence diagrams are provided below.']], 'sub-sections': [
                                    {'h4': '3.2.2.a Add Course ', 'pages': [37], 'paragraphs':[['Instructors are the only ones allowed to add courses to system.',' So, the user should login to the system, and after it is confirmed that user is of type “Instructor” client will provide user with homescreen for instructors.',' User is provided with add course button in the homescreen, and when he/she clicks on it Instructor class will construct a new CourseInfo object that with the properties indicated by user.',' After this process user will be able to get the information of students and teaching assistants so that they can be subscribed to the course.'],['Once these processes are over client will provide user with the viewCourse screen as default. ']], 'sub-sections': []},
                                    {'h4': '3.2.2.b Add Task ', 'pages': [38], 'paragraphs':[['Instructors can add tasks (or homeworks) as part of a course. ','After the login process is completed and the appropriate homescreen is provided to instructor, the button for adding task will be visible to user. ','Following the click on the button there will be a new TaskInfo object constructed according to the specifications indicated by instructor.',' Then, this newly created task will be added to the appropriate CourseInfo instance.']], 'sub-sections': []},
                                    {'h4': '3.2.2.c Edit Task ', 'pages': [38,39], 'paragraphs':[['In some cases instructor may need to edit task info, for example the test inputs may had been initially wrong and instructor would want to change the wrong inputs with the correct ones, or the responsible TA might want to try his own test inputs.',' In order to do this user should login, and once the homescreen is ready he/she should select a particular task and click on Edit Task button. ','After the button is clicked there will be a new TaskInfo object constructed with respect to the attributes indicated by user, and then the copy constructor of the original TaskInfo object will take the new TaskInfo as it’s parameter. ','Hence, the task will be edited. ']], 'sub-sections': []},
                                    {'h4': '3.2.2.d Submit Code ', 'pages': [39,40], 'paragraphs':[['In order to submit code to the system students should first login, and then click the submit code button.',' This will trigger the createSubmission() method of Student object and it will eventually create a SubmissionInfo object and deliver it to the core (evaluator) for analysis and grading. ']], 'sub-sections': []}]}]}]},
            {'h1': '4. Design', 'pages': [40,41,42,43,44,45,46,47,48,49,50,51,52,53,54], 'paragraphs':[[]], 'sub-sections': [
                    {'h2': '4.1 Design Goals ', 'pages': [40,41,42], 'paragraphs':[['Before we start the design and implementation phase, it is important to decide main design goals for the system according to the mentioned non-functional requirements.',' In this section we provide the quality features that we decided to which system design should focus on.']], 'sub-sections': [
                            {'h3': '4.1.1 End User Criterias', 'pages': [40,41], 'paragraphs':[['-Ease of use:',' Web client that grader++ should provide to users must be designed in a way that there will not be any unnecessary pages that users should visit in order to execute simple tasks.',' For example, students will not be needing to visit a new page for viewing the list of courses they are registred to, the list will be provided on the homepage.',' This approach will lead the UI to be simple and end-user friendly.'],['-Ease of learning:',' Web client should not include any terms or concepts other than users already know from their academical life, so that there won’t be need for any extra effort on users’ side to get familiar with using web client. ']], 'sub-sections': []},
                            {'h3': '4.1.2 Maintenance Criterias', 'pages': [41], 'paragraphs':[['-Portability: ',' It is important that users can access and interact with grader++ easily.',' Because of this fact, we decided to implement the user interface as web site, so that users can access grader++ from their computers, tablets, and smart phones. '],['-Extendability:',' Grader++ will be easily extandable, since we are planning our system to be used by not only for one course. ','New courses with new needs of  different evaluator systems should be easily added, since we decided to implement a modular system for evaluators and their work flow in core server. ']], 'sub-sections': []},
                            {'h3': '4.1.3 Performance Criterias', 'pages': [41], 'paragraphs':[['-Response time: ','Grader++ should have minimium response times.',' It is important that users can see the results of evaluation progresses for their submissions, so that they can get the feedback on their submissions and can be aware of any errors they made, and eventually have enough time to do modifications before due dates of homeworks. ']], 'sub-sections': []},
                            {'h3': '4.1.4 Dependability Criterias', 'pages': [41,42], 'paragraphs':[['-Availability:',' It is high likely that there will be significant amount of loads near homework due dates.',' In order to overcome this work load we divided the system and do evaluation on a seperate server named “core”. ','Core should evaluate submissions as concurrently as possible, so that system can respond to as many people as possible at the same time. '],['-Security:',' There will be need of security measurements for core server, since one of it’s possible job is to compile codes and execute it there might be malicious attempts to hack the system.',' In order to prevent these situations, there should be container systems such as Docker. ']], 'sub-sections': []},
                            {'h3': '4.1.5 Trade-offs', 'pages': [42], 'paragraphs':[['-Ease of use and learning vs. Functionality:',' In order to achieve friendly user interface system should include only necessary ui components to provide users with. ','Our aim should be on the side of ease of use, however we should make every necessary action on the application domain available for users.'],['-Response times and Availability vs. Deployment cost:',' In order to have a high percentage of available time there might be need for relatively expensive servers. ','In order to solve this issue, core should be coded as optimized as possible in implementation phase.']], 'sub-sections': []}]},
                    {'h2': '4.2 Subsystem Decomposition', 'pages': [42,43,44], 'paragraphs':[['There are 2 distinguishable main parts of Grader++ subsystem',': The client part, which will generate output which will be consumable by browsers(html, css, javascript), and is responsible for coordinating Users when adding tasks, submitting code and viewing results, and core server part which will be responsible of evaluating submitted codes in an uniform and secure sandbox environment, and lastly.',' Also client and core server part will share storage in order to communicate submission results.  '],['For the client part, we are using MVC pattern in which GraderppWeb subsystem provides a front end for users to initiate all use cases (e.g. EditTask, SubmitCode, ViewSubmissions) as a View part in MVC. ','The GraderppServer subsystem is responsible for access control and initiates the Models, hence the Controller.'],['Different subsystems are dedicated to the models of users, tasks, submissions and synchronizing submission files and test case files to the core server and will update Views as the Model part.',' Also Model subsystem will be persisted by  GraderppStorage subsystem, responsible for storing any persistent objects, it will use filesystem for storing submissions and test cases and MongoDB for storing everything else.',' Fig 4.2.1 shows client part component diagram. '],['For the core server part, we select three-tier architectural style in which an CoreClient subsystem will hide all the complexity behind core server and offer a clean api for the client part as a front-end which provides functionality for submitting code, task descriptions and recieving feedback. ','The CoreWorker subsystem will orchestrate the grading operations in a queue manner, Evaluator Subsystem will determine how the tasks will be graded, and together they will form Application Logic layer. ','Bottom tier will be realized by CoreStorage subsystem, responsible for storing submitted codes and test cases and submission results, and Environment subsystem which will provide a secure environment for Evaluator to assess the submissions. ','Fig 4.2.2 shows core server component diagram']], 'sub-sections': []},
                    {'h2': '4.3 Architectural Patterns', 'pages': [44,45,46,47,48,49,50], 'paragraphs':[[]], 'sub-sections': [
                            {'h3': '4.3.1 MVC Pattern ', 'pages': [44,45,46], 'paragraphs':[['MVC (Model-View-Controller) pattern is one of the most fundamental design patterns in our project.',' Its main goal is to make a clear separation between Models as plain data, Views as visualization of the data and Controllers which makes the control flow between models and their views. ','In our client subsystem we used MVC pattern. '],['In the client side of our project we use many View objects (MenuModel, XHTML files etc.) for providing visible web pages to user; Model objects (Course, Submission, User, Task etc.) to represent data; Controller objects (Homepage, CodeSubmitPage, TaskManagerPage etc.) to make all the operations between those two. ']], 'sub-sections': []},
                            {'h3': '4.3.2 Singleton Pattern ', 'pages': [46,47], 'paragraphs':[['Singleton pattern is about instantiating a single object of a class and using it during the life-period of the application.',' At client side, we use this pattern with LoginController, DatabaseConnectionService, ServerConnectionService and WorkerQueue classes.',' They are all singleton classes, instantiated once and injected into required classes at the start of the application life-cycle.  '],['● When User logs in to the system, we instantiate a LoginController object and inject it on each page controller class since we need to check whether authorization process is done or not before showing the page to a user. '],['● DatabaseConnectionService is used for making all the required DB tasks, and ServerConnectionService is used to communicate with remote server. ','We inject their singleton objects to required controller classes and use them. '],['● In core system, we have a singleton class named WorkerQueue.',' This class is instantiated once at the start-up of the server, and used all along the life-period of server. ','This class is responsible for orchestrating Worker objects. ','It will allow us to assign our resources to the tasks in a well defined behaviour and prevent overloading and system crashes. ']], 'sub-sections': []},
                            {'h3': '4.3.3 Façade Pattern ', 'pages': [47,48], 'paragraphs':[['Façade Pattern is about enclosing the complex processes via interfaces and simplifying the procedure of complicated and big operations.',' We use Façade classes to access to the remote server and database. ','Database has many operations such as getting the tasks of a specific course or finding a submission with given id, and our System is to connect to our RemoteServer and send the code files to it.',' However, those operations is being done at the deep of our system with huge and complicated code, but we want to make these frequent tasks easier in our page controller classes.',' Therefore, we designed Façade classes to be an intermediate between our external systems and client side application. '],['In client side, We use DatabaseConnectionService and ServerConnectionService to make those operations much more easily with a couple lines of code.',' DatabaseConnectionService provides us methods like findTaskById(), setCourseList() to retrieve and manipulate data easily in page controller classes.'],['ServerConnectionService make the file submission process simpler as well via HTTP requests.'],['In our core system, another Façade class named as CoreFacade exists. ','It provides an interface to make complex operations just by calling a single function like evaluateSubmission() or addTask().',' Also core part of the subsystem composition, uses three layered architecture and CoreFacade is a part of CoreClient subsystem. ']], 'sub-sections': []},
                            {'h3': '4.3.4 Data Access Object (DAO) Pattern', 'pages': [48,49], 'paragraphs':[['Data Access Object Pattern is used to make operations on database with the POJO model classes (Plain-old Java Objects).',' Data operations can be simplified by separating low level details from high-level uses.',' We have DAO classes for each of our models and we can make CRUD operations (Create, Read, Update, Delete) on the database with the help of them. ']], 'sub-sections': []},
                            {'h3': '4.3.5 Three-tier Architectural Style ', 'pages': [49,50], 'paragraphs':[['In core part of our system decomposition we used three layered architecture. ','Interface layer is provided by CoreFacade class, Application logic layer have two classes: CoreWorker and Evaluator.',' CoreWorker orchestractes evaluations and Evaluator will do the work on Environment given by CoreWorker.',' Bottom tier will be realized by CoreStorage which will persist task data and Environment subsystem will use system resources to realize evaluations.  ','Following figures, 4.3.7-10 will show which class is belonging to which layer in our design. ']], 'sub-sections': []}]},
                    {'h2': '4.4 Hardware/Software Mapping ', 'pages': [50,51], 'paragraphs':[['Mapping subsystems to processors and components enables us to identify potential concurrency among subsystems and to address performance and reliability goals. ','In Grader++ project, we use three servers, one for ClientController subsystem and one for core part and one for both storage parts of client part and core part. ','For the Environment subsystem we plan to use Docker (​ https://www.docker.com/​ ), in order to provide security design goal.',' All of the submissions will be run in different docker environments and since docker is very lightweight, it won’t make us compromise our performance goal. ','In core part, CoreClient will providehttp interface through an undecided web server container like Tomcat or Glassfish.',' Fig 4.4.1 shows our deployment diagram. ']], 'sub-sections': []},
                    {'h2': '4.5 Addressing Key Concerns ', 'pages': [52,53,54], 'paragraphs':[[]], 'sub-sections': [
                            {'h3': '4.5.1 Persistent Data Management ', 'pages': [52], 'paragraphs':[['Data management is one of the significant parts of the system.',' Grader++ requires storing lots of data such as user information, tasks, courses and submissions. ','These data must stay persistent, and for this purpose we chose to use database systems instead of using file system.',' Using a database system can make system maintainable and easy to operate.',' Data should be accessible by multiple users such as students, TAs, and instructors.',' We decided to use MongoDB database system because of it’s ease of the fact that it is a lightweight system. ','In our database, many types of persistence data are used. ','First one is for storing personal information of users.',' In order to use Grader++, users must log in. ','Therefore, their personal information such as user name and password are stored in database. ','Database should also store courses, tasks and submissions.',' For submissions, students will be allowed to submit only specified amount of submissions for a certain task. ']], 'sub-sections': []},
                            {'h3': '4.5.2 Access Control and Security ', 'pages': [52,53], 'paragraphs':[['There are 3 different types of actors anticipated for using Grader++: students, TAs and instructors.',' Accessibility permissions of Grader++ is different for each actor. ','Firstly, students can only see the tasks that are scheduled for the courses that they are taking. ','Students can only see the active tasks. Student can see their previous submissions. ','Other than these actions, students cannot do anything. ','TA can only see the tasks that are assigned to the courses that they subscribed.',' TAs can see both active tasks and closed tasks.',' TA can list previous submissions. ','TAs can edit tasks. ','Individual instructors can see the tasks created by any other instructor of the same course.',' Instructors are only allowed to see the courses that he generated.',' Instructor can add or delete tasks. ','Instructors can add or delete courses.']], 'sub-sections': []},
                            {'h3': '4.5.3 Global Software Control', 'pages': [53], 'paragraphs':[['For every part of Grader++ using event driven control systems would be reasonable.',' Because of the nature of Grader++ that always waits for user actions, and tries to respond accordingly. ','Even though it is generally event driven, different parts use various patterns and systems. '],['For client part (UI) of Grader++ we plan to use Model-View-Controller (MVC) architecture. ','Although MVC is not the fastest, it is the appropriate choice for developing a maintainable and scalable event driven system.',' Views waits for action.',' If action occurs, view assigns it to controller.',' Controller goes to model if it is needed.',' To get data client calls database. To submit a code, it calls methods from core.',' Core evaluates codes and responds when it is ready. '],['Between core and UI there is facade pattern. ','Facade pattern mainly operates when student submits a code. ','Interface in this pattern will provide necessary connections between UI and core. ']], 'sub-sections': []},
                            {'h3': '4.5.4 Boundary Conditions ', 'pages': [54], 'paragraphs':[['Initialization:​ ','Simply, client side of Grader++ is a web-based classical server-client system.',' An Internet connection is enough to interact with system.',' Grader++ uses Java to evaluate codes and to form user-interface.',' To use Grader++ actually, user needs to have an account.',' Student and TA can create an account through website.',' For instructors, they should contact system administrator to create an account.',' When user logs in to Grader++, home page will be shaped specifically according to the user type.',' For all of the users, fetching some data from database is necessary. ','The reason is all the data will be stored in servers.',' Data is not going to be big because there is no any image or media data, but will be text.',' Hence, start-up of system should also be fast. '],['Termination:','​ Single subsystems are not allowed to terminate individually, since they are all needed for the system’s continuity.',' If a subsystem terminates because of a fatal error, the whole system needs to be rebooted.',' Since system is light-weighted it is not a big deal.',' We are going to be using MongoDB behind the scene, in order to implement the database. '],['Failure:','​ All the data we need to keep are tasks, submissions, courses and user information. ','System will be designed to keep these data in the database all the time and fetch the data whenever it is needed.',' Therefore, during fetching data if any communication link or a router fails nothing will be lost.',' System needs to be refreshed. ','If there is a problem during writing data to database, there might be problems.',' MongoDB is a powerful database system. ','We think that most of the time MongoDB will handle these problematic situations in the background. ']], 'sub-sections': []} ]}]},
            {'h1': '5. Conclusion', 'pages': [55], 'paragraphs':[['In this report, we have focused on what the system should do, what functions it should include, and with the design part we thought of the general implementation and design decisions. ','However we have not started the system implementation. ','Expected features of the system and given requirements were our main helper to form use case models and their scenarios in analysis part of report. '],['Writing the analysis report was a useful process because it helped us to think about the design process thoroughly even before we started the design and implementation phase.',' Because of this, we were able to easily make designing decisions. ','In this report, our main target was to make people understand the analysis of our system and explain our user-friendly system for students and instructors for the analysis part. ','To achieve this goal, we used design tools such as Visual Paradigm, and used Unified Modeling Language (UML).',' Since UML is a unique programming language, it really helped us to communicate with other people easily.  ','Designing part of the report was to explain the design process and, help in deciding our general implementation path. ','We used Visual Paradigm to create our UML diagrams such as deployment diagram, component diagram, use case diagrams, class diagram, sequence diagrams, state and activity diagrams etc.',' Finally, in the report, we also discussed and eventually decided how user interface should be formed by taking design goals into account such as user friendliness. ','We decided how system should respond to the user actions. ','We generally tried to provide understandable and informative user interface. ','We want our users to reach their goal with just a few steps.',' Consequently, we detailed our core and UI designs to implement them in object-oriented fashion.']], 'sub-sections': []}]







